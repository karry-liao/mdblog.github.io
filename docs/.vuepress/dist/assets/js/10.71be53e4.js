(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{283:function(t,e,r){"use strict";r.r(e);var v=r(11),s=Object(v.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"vue"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[t._v("#")]),t._v(" Vue")]),t._v(" "),e("blockquote",[e("p",[e("strong",[t._v("生命周期钩子的this上下文指向调用它的vue实例")])])]),t._v(" "),e("p",[t._v("不能再生命周期选项property或回调上使用箭头函数如")]),t._v(" "),e("p",[t._v("created: () => console.log(this.a)   或")]),t._v(" "),e("p",[t._v("vm.$watch('a', newValue => this.myMethod())。**因为箭头函数并没有 "),e("code",[t._v("this")]),t._v("，"),e("code",[t._v("this")]),t._v(" 会作为变量一直向上级词法作用域查找，直至找到为止，**经常导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类的错误")]),t._v(" "),e("p",[e("strong",[t._v("beforecreate：")])]),t._v(" "),e("p",[e("strong",[t._v("created：")])]),t._v(" "),e("p",[e("strong",[t._v("beforemounted:")])]),t._v(" "),e("p",[e("strong",[t._v("mounted:")])]),t._v(" "),e("p",[e("strong",[t._v("beforeupdated:")])]),t._v(" "),e("p",[e("strong",[t._v("update:")])]),t._v(" "),e("p",[e("strong",[t._v("beforedestroyed:")])]),t._v(" "),e("p",[e("strong",[t._v("destroyed:")])]),t._v(" "),e("h2",{attrs:{id:"_1-什么是vue生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是vue生命周期"}},[t._v("#")]),t._v(" （1）什么是vue生命周期?")]),t._v(" "),e("p",[t._v("Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。")]),t._v(" "),e("h3",{attrs:{id:"_2-vue生命周期的作用是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-vue生命周期的作用是什么"}},[t._v("#")]),t._v(" （2）vue生命周期的作用是什么?")]),t._v(" "),e("p",[t._v("Vue生命周期中有多个事件钩子，让我们在控制整个Vue实例过程时更容易形成好的逻辑。")]),t._v(" "),e("h3",{attrs:{id:"_3-vue生命周期总共有几个阶段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-vue生命周期总共有几个阶段"}},[t._v("#")]),t._v(" （3）vue生命周期总共有几个阶段?")]),t._v(" "),e("p",[t._v("可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/后。")]),t._v(" "),e("h3",{attrs:{id:"_4-第一次页面加载会触发哪几个钩子"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-第一次页面加载会触发哪几个钩子"}},[t._v("#")]),t._v(" （4）第一次页面加载会触发哪几个钩子?")]),t._v(" "),e("p",[t._v("第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子")]),t._v(" "),e("h3",{attrs:{id:"_5-dom-渲染在-哪个周期中就已经完成"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-dom-渲染在-哪个周期中就已经完成"}},[t._v("#")]),t._v(" （5）DOM 渲染在 哪个周期中就已经完成?")]),t._v(" "),e("p",[t._v("DOM 渲染在 mounted 中就已经完成了。")]),t._v(" "),e("h3",{attrs:{id:"_6-简单描述每个周期具体适合哪些场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-简单描述每个周期具体适合哪些场景"}},[t._v("#")]),t._v(" （6）简单描述每个周期具体适合哪些场景?")]),t._v(" "),e("p",[t._v("生命周期钩子的一些使用方法：")]),t._v(" "),e("p",[t._v("beforecreate : 可以在此阶段加loading事件，在加载实例时触发；")]),t._v(" "),e("p",[t._v("created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用；")]),t._v(" "),e("p",[t._v("mounted : 挂载元素，获取到DOM节点；")]),t._v(" "),e("p",[t._v("updated : 如果对数据统一处理，在这里写上相应函数；")]),t._v(" "),e("p",[t._v("beforeDestroy : 可以做一个确认停止事件的确认框；")]),t._v(" "),e("p",[t._v("nextTick : 更新数据后立即操作dom；")]),t._v(" "),e("h1",{attrs:{id:"vue进阶-一"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue进阶-一"}},[t._v("#")]),t._v(" VUE进阶(一)")]),t._v(" "),e("div",{staticClass:"language-vue extra-class"},[e("pre",{pre:!0,attrs:{class:"language-vue"}},[e("code",[t._v("//添加一个请求拦截器\naxios.interceptors.request.use(function (config){\n\treturn config;\n},function (error) {\n\treturn Promise.reject(error);\n});\n\n//添加一个响应拦截器\naxios.interceptors.responese.use(function (responese){\n\treturn responese;\n},function (error){\n\treturn \tPromise.reject(error);\n})\n\n//移除一个拦截器\nvar = myInterceptor = axios.interceptors.request.use(function (){ .... });\naxios.interceptors.request.eject(myInterceptor);\n\n//给自定义的axios实例添加拦截器\nvar instance = axios.create();\ninstance.interceptors.request.use(function() { ....});\n\n\n")])])]),e("h2",{attrs:{id:"axios的方法和请求响应数据结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#axios的方法和请求响应数据结构"}},[t._v("#")]),t._v(" axios的方法和请求响应数据结构")]),t._v(" "),e("h3",{attrs:{id:"请求方法别名"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#请求方法别名"}},[t._v("#")]),t._v(" 请求方法别名")]),t._v(" "),e("p",[t._v("​\tget、delete、head、post、put、patch")]),t._v(" "),e("h3",{attrs:{id:"相应数据结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#相应数据结构"}},[t._v("#")]),t._v(" 相应数据结构")]),t._v(" "),e("p",[t._v("​\tdata:{},")]),t._v(" "),e("p",[t._v("​\tstatus:200?")]),t._v(" "),e("p",[t._v("​\tstatusText: 'ok'")]),t._v(" "),e("p",[t._v("​\theaders: {}")]),t._v(" "),e("p",[t._v("​\tconfig: {}")]),t._v(" "),e("h2",{attrs:{id:"在vue中封装axios"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在vue中封装axios"}},[t._v("#")]),t._v(" 在VUE中封装axios")]),t._v(" "),e("p",[e("strong",[t._v("mutations")]),t._v("中的state，接收Vuex中的state对象。")]),t._v(" "),e("p",[e("strong",[t._v("action")]),t._v("中固有的参数——context，context是state的父级，包含getters和state")]),t._v(" "),e("h3",{attrs:{id:"请求响应之then-catch"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#请求响应之then-catch"}},[t._v("#")]),t._v(" 请求响应之then  catch")]),t._v(" "),e("p",[t._v("请求响应成功执行.then的内容，失败执行 .catch内容")]),t._v(" "),e("p",[t._v(".then .catch都有自己的作用域，无法在里面直接访问this，无法访问Vue实例。只需添加**.bind(this)**就可以解决")]),t._v(" "),e("h2",{attrs:{id:"vuex状态管理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vuex状态管理"}},[t._v("#")]),t._v(" Vuex状态管理")]),t._v(" "),e("p",[t._v("**state：**驱动应用的数据源。")]),t._v(" "),e("p",[t._v("**view：**以声明的方式将state映射到视图")]),t._v(" "),e("p",[t._v("**actions：**响应在vue上的用户输入导致的状态变化。")]),t._v(" "),e("p",[t._v("state会显示到view，用户根据view上的内容进行操作，触发actions然后在影响state的变化。")]),t._v(" "),e("h2",{attrs:{id:"vue中router的钩子函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue中router的钩子函数"}},[t._v("#")]),t._v(" VUE中router的钩子函数")]),t._v(" "),e("p",[e("strong",[t._v("beforeEach")]),t._v("：在跳转之前执行")]),t._v(" "),e("p",[e("strong",[t._v("to:router")]),t._v(" 即将进入路由对象")]),t._v(" "),e("p",[e("strong",[t._v("from")]),t._v(":当前导航即将离开路由")]),t._v(" "),e("p",[e("strong",[t._v("next")]),t._v(":Function，进行管道中的钩子，如果执行完了，如果执行完了，当前导航的状态为confirmed(确认的)，false，即终止导航。")]),t._v(" "),e("div",{staticClass:"language-vue extra-class"},[e("pre",{pre:!0,attrs:{class:"language-vue"}},[e("code",[t._v('router.beforeEach((to,from,next)=>{\n\n​\tlet token = router.app.$storage.fetch("token");\n\n​\tlet needAuth = to.matched.some(iten=>item.meta.login);\n\n​\tif(!token&& needAuth) return next({\n\n​\t\tpath: "/login";\n\n​\tnext();\n\n})\n\n})\n')])])]),e("p",[t._v("**afterEach：**在跳转之后判断")]),t._v(" "),e("p",[e("strong",[t._v("aftereach")]),t._v("：不用传next（）函数。")]),t._v(" "),e("div",{staticClass:"language-vue extra-class"},[e("pre",{pre:!0,attrs:{class:"language-vue"}},[e("code",[t._v("const = router = new VueRouter({\n\n​\troutes: [\n\n​\t{\n\n​\tpath: '/login',\n\n​\tcomponent: Login,\n\n​\tbeforeEnter:(to,from,next)=>{\n\n​\t\t//.....\n\n},\n\n​\tbeforeLeave:(to,from,next)=>{\n\n​\t\t//....\n\n}\n\n}\n\n]})\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var routes = [\n\n{\n\n​\tpath:'/home',\n\n​\tcomponent: 'home',\n\n​\tname: 'home'\n\n}\n\n]\n")])])]),e("p",[t._v("beforeRouteLeave(to, from, next) {\nnext()\n},\nbeforeRouteEnter(to, from, next) {\nnext()\n},\nbeforeRouteUpdate(to, from, next) {\nnext()\n},")]),t._v(" "),e("h2",{attrs:{id:"es6的基本知识"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#es6的基本知识"}},[t._v("#")]),t._v(" ES6的基本知识")]),t._v(" "),e("p",[t._v("​\t"),e("strong",[t._v("let")]),t._v("：(代码块)块级作用域，不存在变量提升变量声明后必须 使用，在相同作用域内，不允许重复声明。")]),t._v(" "),e("p",[e("strong",[t._v("const")]),t._v(":声明一个只读常量，一旦声明不发改变，声明后必须初始化一个值，const的作用域与let相同，只在块级作用域下有效，不可重复声明，没有变量提升。")]),t._v(" "),e("p",[e("strong",[t._v("var")]),t._v("：存在变量提升，作用域为该语句所在的函数内。")]),t._v(" "),e("h2",{attrs:{id:"promise"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[t._v("#")]),t._v(" Promise")]),t._v(" "),e("p",[e("strong",[t._v("promise")]),t._v("对象是一个构造函数，用来生成Promise实例。")]),t._v(" "),e("p",[e("strong",[t._v("promise")]),t._v("对象代表一个异步操作，有三种状态："),e("strong",[t._v("pending")]),t._v("(进行中)，"),e("strong",[t._v("fulfiled")]),t._v("(已成功)、"),e("strong",[t._v("rejected")]),t._v("(已失败)")]),t._v(" "),e("p",[e("strong",[t._v("1.Promise.all")]),t._v("方法用于将多个Promise实例，包装成一个新的Promise实例。")]),t._v(" "),e("p",[t._v("var p =Promise.all([p1,p2,p3]);")]),t._v(" "),e("p",[t._v("Promise.all方法接受一个数组作为参数，p1,p2,p3都是Promise实例,如果不是就会先调用下面讲到的"),e("code",[t._v("Promise.resolve")]),t._v("方法，将参数转为 Promise 实例，再进一步处理。")]),t._v(" "),e("p",[t._v("P的状态由p1,p2,p3决定：")]),t._v(" "),e("p",[t._v("​\t1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。")]),t._v(" "),e("p",[t._v("2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。")]),t._v(" "),e("p",[e("strong",[t._v("2")]),t._v("."),e("strong",[t._v("Promise.race()")]),t._v(":将多个Promise实例，包装成一个新的Promise实例。")]),t._v(" "),e("p",[t._v("​\t\t var p = Promise.race([p1, p2, p3]);")]),t._v(" "),e("p",[t._v("上面代码中，只要"),e("code",[t._v("p1")]),t._v("、"),e("code",[t._v("p2")]),t._v("、"),e("code",[t._v("p3")]),t._v("之中有一个实例率先改变状态，"),e("code",[t._v("p")]),t._v("的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给"),e("code",[t._v("p")]),t._v("的回调函数。")]),t._v(" "),e("p",[e("strong",[t._v("3.Promise.resolve()")]),t._v(":将现有对象转换为Promise对象。")]),t._v(" "),e("h2",{attrs:{id:"vue-store存储commit和dispatch"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-store存储commit和dispatch"}},[t._v("#")]),t._v(" vue store存储commit和dispatch")]),t._v(" "),e("p",[t._v("this.$store.dispatch('toShowLoginDiaglog',false)")]),t._v(" "),e("p",[t._v("this.$store.commit('toShowLoginDoalog',false)")]),t._v(" "),e("p",[e("strong",[t._v("区别")]),t._v("：dispatch：含有异步操作  写法：“"),e("code",[t._v("this.$store.dispatch('action方法名',值)")])]),t._v(" "),e("p",[t._v("​\t\t\tcommit:同步操作，this.$store.commit('mutations方法名',值)")]),t._v(" "),e("h2",{attrs:{id:"vue-路由导航"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-路由导航"}},[t._v("#")]),t._v(" vue  路由导航")]),t._v(" "),e("p",[e("strong",[t._v("编程式")]),t._v("：\t"),e("strong",[t._v("router.push(location)")]),t._v(",向history添加新纪录，可通过浏览器的前进后退按钮进行浏览器页面跳转。")]),t._v(" "),e("p",[e("strong",[t._v("声明式")]),t._v("："),e("code",[t._v('<router-link :to=""></router-link>')]),t._v("等同于router.push(location)")]),t._v(" "),e("p",[e("strong",[t._v("router.replace()")]),t._v(":不会在history留下记录，即使点击返回按钮也不会回到这个页面，替换当前记录。")]),t._v(" "),e("h2",{attrs:{id:"vue中computed和method-区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue中computed和method-区别"}},[t._v("#")]),t._v(" vue中computed和method 区别")]),t._v(" "),e("p",[t._v("computed是属性调用，而method是函数调用;")]),t._v(" "),e("p",[t._v("computed带有缓存功能，而method没有。")])])}),[],!1,null,null,null);e.default=s.exports}}]);